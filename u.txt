import os
import sys
import tempfile
import shutil
import zipfile
import tarfile
import time
import stat  # Добавлен импорт модуля stat
from fuse import FUSE, Operations, LoggingMixIn

class AutoUnzipFS(LoggingMixIn, Operations):
    def __init__(self, original_root):
        self.original_root = os.path.abspath(original_root)
        self.temp_dirs = {}

    def _get_archive_type(self, path):
        if path.endswith('.zip'):
            return 'zip'
        elif path.endswith('.tar.gz') or path.endswith('.tgz'):
            return 'tar.gz'
        return None

    def _extract_archive(self, archive_path):
        if archive_path in self.temp_dirs:
            return self.temp_dirs[archive_path]

        temp_dir = tempfile.mkdtemp()
        try:
            archive_type = self._get_archive_type(archive_path)
            if archive_type == 'zip':
                with zipfile.ZipFile(archive_path, 'r') as zip_ref:
                    zip_ref.extractall(temp_dir)
            elif archive_type == 'tar.gz':
                with tarfile.open(archive_path, 'r:gz') as tar_ref:
                    tar_ref.extractall(temp_dir)
            self.temp_dirs[archive_path] = temp_dir
            return temp_dir
        except Exception as e:
            shutil.rmtree(temp_dir)
            raise e

    def getattr(self, path, fh=None):
        original_path = os.path.join(self.original_root, path.lstrip('/'))
        st = os.lstat(original_path) if os.path.exists(original_path) else None

        # Виртуальные директории архивов
        for archive_path, temp_dir in self.temp_dirs.items():
            archive_name = os.path.splitext(os.path.basename(archive_path))[0]
            if path == f'/{archive_name}':
                return {
                    'st_mode': (0o555 | stat.S_IFDIR),  # Исправлено: stat.S_IFDIR
                    'st_size': 0,
                    'st_atime': time.time(),
                    'st_mtime': time.time(),
                    'st_ctime': time.time(),
                    'st_uid': os.getuid(),
                    'st_gid': os.getgid(),
                    'st_nlink': 2
                }
            if path.startswith(f'/{archive_name}/'):
                virtual_path = os.path.join(temp_dir, path.split(f'/{archive_name}/')[1])
                if os.path.exists(virtual_path):
                    st = os.lstat(virtual_path)
                    return dict((key, getattr(st, key)) for key in ('st_mode', 'st_size', 
                        'st_atime', 'st_mtime', 'st_ctime', 'st_uid', 'st_gid', 'st_nlink'))

        # Обычные файлы и архивы
        if st and self._get_archive_type(original_path):
            return {
                'st_mode': (0o444 | stat.S_IFREG),  # Исправлено: stat.S_IFREG
                'st_size': st.st_size,
                'st_atime': st.st_atime,
                'st_mtime': st.st_mtime,
                'st_ctime': st.st_ctime,
                'st_uid': st.st_uid,
                'st_gid': st.st_gid,
                'st_nlink': st.st_nlink
            }

        # Дефолтная обработка
        return dict((key, getattr(st, key)) for key in ('st_mode', 'st_size', 
            'st_atime', 'st_mtime', 'st_ctime', 'st_uid', 'st_gid', 'st_nlink')) if st else {}

    # Остальные методы (readdir, read, mkdir, destroy) остаются без изменений
    # ...

if __name__ == '__main__':
    if len(sys.argv) != 3:
        print(f"Usage: {sys.argv[0]} <original_dir> <mount_point>")
        sys.exit(1)

    FUSE(
        AutoUnzipFS(sys.argv[1]),
        sys.argv[2],
        foreground=True,
        nothreads=True,
        allow_other=True  # Разрешить доступ другим пользователям
    )
